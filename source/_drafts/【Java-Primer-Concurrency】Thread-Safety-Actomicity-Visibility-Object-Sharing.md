---
title: 【Java Primer - Concurrency】Thread Safety & Actomicity & Visibility & Object
  Sharing
date: 2017-02-23 19:14:39
categories: [Java, Java Primer, Concurrency]
tags: [Java, Concurrency]
description:
---

本文对于Java线程安全和对象共享的内容进行一些初步总结，重点是帮助自己理清思路，关联一些零散知识点。大神移步，小白入。

《Java Concurrency in Practice》第三章中对对象共享部分的讲解比较散乱，特别是对象发布这一块。下面主要按照我自己的理解对线程安全以及对象共享部分进行梳理总结。

<!-- more -->

## Thread Safety

我们经常将线程安全挂在嘴边，但是到底什么是线程安全？那些做法会威胁到线程安全？



下面这张图可以反映出实现线程安全的几种途径以及注意事项，也可以用作对书中第三章内容的梳理：





## Actomicity

原子性这个概念在很多地方都会用到，比如数据库，比如多线程。尽管原子性操作通常被统一定义为不能被打断的操作，但是在不同的应用场景和语境下，原子性的定义还是会有差别。

这里主要讨论并发环境下的原子性操作。不能被“打断”的操作，何谓”打断“？就是指CPU将**操作X**执行了一半，中途跑去执行其它操作，这样**操作X**就被打断了，**操作X**并不是原子操作。原子操作要么完全不执行，一旦开始执行，就必须执行完。

并发编程为什么要引入原子性的概念？



CPU 保证的原子性操作 vs 锁保护的原子性操作



对于CPU架构所保证的原子性操作是一种绝对原子性操作； 锁保护的原子性操作是一种相对原子性操作。

《Java Concurrency in Practice》中对原子性操作的定义如下：

Operations  A  and  B  are  atomic  with  respect  to  each  other  if,  from  the  perspective  of  a  thread executing  A,  when another thread executes B, either all of B has executed or none of it has. An atomic operation is one that is atomic **with respect to all operations**, including itself, that operate on the same state. 

上面这段话，简而言之，在**多线程环境**下，如果对于**其他线程中**所有**访问同一个共享状态**的操作（简称操作集合X）而言，操作A要么全部执行完，要么完全不执行，那么操作A**对于操作集合X中的所有操作而言**是原子的。

理解原子性的关键在于认清一个操作是否是原子的，在于这个操作的参照系是什么。原子性是一种相对性的概念而非一种绝对的定义，我们无法在没有任何对比，没有任何参照系的情况下孤立地判断某个操作是否是原子操作。一个操作A只有在另一个访问共享状态的操作B的观察下才能判断该操作是否是原子的。**原子性多线程环境下又被称为是“互斥性”**，互斥性这个名字更加形象，它从字面上就表现出了这是一个相对性的概念。

可以揣摩一下这个例子，加深上述概念的理解。
操作A和操作B都需要访问共享对象M的状态，操作C不需要访问任何操作A和操作B需要访问的对象。请判断下面的三种说法的正误：

1. 操作A是原子操作
2. 操作A对于操作B而言是原子操作
3. 操作A对于操作C而言是原子操作

第一种说法不一定正确，它将原子性当做一种绝对的定义，而事实上，原子性可能是一种相对的概念。如果说



只能说X对于Y是原子的，而不能单独判断说X是原子的。但是我们又经常在各种书和博客下看到第一种说法，原因在于一般而言我们都省略了一种默认参照系，实际上想说的是：操作A（对于其他所有访问共享状态的操作而言）是原子操作。

第二种说法，在程序进行了恰当同步的前提下，是正确的说法。

第三种说法没毛病，但是这种说法没什么意义的，对于不访问共享状态的两个操作而言，没有讨论它们是否互为原子操作的意义。这样的两个操作，即使编译器或处理器进行指令重排序，两个操作被中断交叉执行，也不会对程序最终的执行结果造成任何影响。

在单线程的背景下并没有所谓的原子性的概念，因为单线程的所有操作都是串行的，不存在线程间的数据共享，对于单线程中的任意两个操作一定是互为原子操作（对于一个操作而言，另一个操作一定是要么执行完了，要么完全没执行），因此在单线程环境下没有讨论原子性的必要。

> 这里可能会涉及到一个疑问，单线程中的重排序是否会导致某些操作对于另外一些操作而言并非原子的（比如由于重排序，第二个操作的某些指令被重排序到第一个操作的指令序列中间）？
>
> 这个问题其实也很容易解决，如果这些操作都互不访问共享状态，则没有讨论它们是否互为原子操作的意义；如果这些操作都会访问某些共享状态，对于单个处理器中执行的指令序列和单个线程中执行的操作，编译器和处理器重排序会遵守数据依赖性，即编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。也就是说这种情况下不会重排序访问共享状态的操作，于是保证了和代码顺序一致的串行性。

说了这么多，无非是想证明在单线程下，线程间没有共享数据或者操作间没有共享数据的情况下，没有讨论原子性操作的必要，因为在这些情况下，不管操作间是否互为原子操作，指令被如何重排序，都不会影响程序最后的执行结果。



注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。





上面的定义也描述的很清晰了			

​			
​		
​	

## Visibility

when a thread modifies the state of an object, other threads can actually see the changes that were made

​				
​			
​		
​	



[图！！！]()



## Sharing Objects

什么情况下会使得对象有被多个线程共享的风险？

### runnable中的实例域

### 局部对象引用

对象逸出





## False Sharing

